--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")

--// Variables
local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local aiming = false
local espEnabled = true 
local teamCheck = false
local wallCheck = false
local aimPart = "Head"
local lockToCenter = false
local drawLines = false 

-- Cycle target
local cycleMode = false
local cycleList = {}
local cycleIndex = 0
local aimOverridePart = nil
local CYCLE_LIMIT = 3

-- Thresholds
local ESP_GREEN_THRESHOLD = 8       
local TELEPORT_THRESHOLD  = 30      

-- UI Colors
local COLOR_ENABLED = Color3.fromRGB(0, 200, 0)
local COLOR_DISABLED = Color3.fromRGB(200, 60, 60)
local COLOR_NEUTRAL = Color3.fromRGB(60, 60, 60)

--// UI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AimbotUI_Final"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Enabled = true
screenGui.DisplayOrder = 2147483647 

-- Force parent to CoreGui
local pCallSuccess, _ = pcall(function() screenGui.Parent = CoreGui end)
if not pCallSuccess then screenGui.Parent = player:WaitForChild("PlayerGui") end

-- Helper for buttons
local function createButton(text, size, pos, zindex)
    local btn = Instance.new("TextButton")
    btn.Size = size
    btn.Position = pos
    btn.BackgroundColor3 = COLOR_NEUTRAL
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.Font = Enum.Font.SourceSansBold
    btn.TextSize = 20
    btn.Text = text
    btn.AutoButtonColor = true
    btn.ZIndex = zindex
    btn.Active = true
    btn.Modal = true -- THIS PREVENTS CLICKS FROM GOING THROUGH TO THE GAME
    return btn
end

-- MAIN GEAR & MENU
local gearButton = Instance.new("ImageButton")
gearButton.Size = UDim2.new(0, 40, 0, 40)
gearButton.Position = UDim2.new(0.5, -20, 0.05, 0)
gearButton.BackgroundTransparency = 1
gearButton.Image = "rbxassetid://6031091006"
gearButton.ZIndex = 200
gearButton.Parent = screenGui

local menuFrame = Instance.new("Frame")
menuFrame.Size = UDim2.new(0, 260, 0, 520) 
menuFrame.Position = UDim2.new(0.5, -130, 0.5, -260)
menuFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
menuFrame.BorderSizePixel = 0
menuFrame.Visible = false
menuFrame.ZIndex = 150
menuFrame.Parent = screenGui

local uiList = Instance.new("UIListLayout")
uiList.Parent = menuFrame
uiList.Padding = UDim.new(0, 8)
uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center

-- TOP-RIGHT TELEPORT BUTTON (Consolidated Fix)
local teleportTopRightBtn = createButton(
    "Teleport (<=30)", 
    UDim2.new(0, 200, 0, 44), 
    UDim2.new(1, -12, 0, 12), 
    2147483647
)
teleportTopRightBtn.AnchorPoint = Vector2.new(1, 0)
teleportTopRightBtn.Parent = screenGui

-- BUTTONS INSIDE MENU
local function createMenuToggle(label)
    local b = createButton(label .. ": OFF", UDim2.new(0, 240, 0, 36), UDim2.new(0,0,0,0), 160)
    b.Parent = menuFrame
    return b
end

local aimToggle = createMenuToggle("Auto Aim")
local espToggle = createMenuToggle("ESP")
setmetatable({},{__index=function() espToggle.Text = "ESP: ON" end}) -- Initial state
local teamCheckToggle = createMenuToggle("Team Check")
local wallCheckToggle = createMenuToggle("Wall Check")
local aimPartToggle = createMenuToggle("Aim Part: Head")
local lockCenterToggle = createMenuToggle("Lock To Screen Center")
local drawLinesToggle = createMenuToggle("Draw Lines")
local cycleToggle = createMenuToggle("Cycle Target")
local nextTargetBtn = createButton("Next Target", UDim2.new(0, 240, 0, 36), UDim2.new(0,0,0,0), 160)
nextTargetBtn.Parent = menuFrame
local teleportBehindBtn = createButton("Teleport Behind (<=30)", UDim2.new(0, 240, 0, 36), UDim2.new(0,0,0,0), 160)
teleportBehindBtn.Parent = menuFrame

-- Dragging helper
local function makeDraggable(guiElement)
    local dragging, dragInput, dragStart, startPos
    guiElement.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = guiElement.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            guiElement.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

makeDraggable(gearButton)
makeDraggable(menuFrame)

gearButton.MouseButton1Click:Connect(function() menuFrame.Visible = not menuFrame.Visible end)

-- LOGIC HELPERS
local function setToggleText(btn, label, state) btn.Text = label .. ": " .. (state and "ON" or "OFF") end

aimToggle.MouseButton1Click:Connect(function() aiming = not aiming; setToggleText(aimToggle, "Auto Aim", aiming) end)
espToggle.MouseButton1Click:Connect(function() espEnabled = not espEnabled; setToggleText(espToggle, "ESP", espEnabled) end)
teamCheckToggle.MouseButton1Click:Connect(function() teamCheck = not teamCheck; setToggleText(teamCheckToggle, "Team Check", teamCheck) end)
wallCheckToggle.MouseButton1Click:Connect(function() wallCheck = not wallCheck; setToggleText(wallCheckToggle, "Wall Check", wallCheck) end)
aimPartToggle.MouseButton1Click:Connect(function() aimPart = (aimPart == "Head") and "HumanoidRootPart" or "Head"; aimPartToggle.Text = "Aim Part: " .. aimPart end)
lockCenterToggle.MouseButton1Click:Connect(function() lockToCenter = not lockToCenter; setToggleText(lockCenterToggle, "Lock To Screen Center", lockToCenter) end)
drawLinesToggle.MouseButton1Click:Connect(function() drawLines = not drawLines; setToggleText(drawLinesToggle, "Draw Lines", drawLines) end)

-- TARGETING ENGINE
local function canSeeTarget(part)
    if not wallCheck then return true end
    local origin = camera.CFrame.Position
    local direction = (part.Position - origin)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {player.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = Workspace:Raycast(origin, direction.Unit * direction.Magnitude, rayParams)
    return (result and result.Instance and part:IsDescendantOf(result.Instance.Parent)) or not result
end

local function acquireTargetPart()
    if cycleMode and aimOverridePart and aimOverridePart.Parent then return aimOverridePart end
    local closest, shortest = nil, math.huge
    local myPos = camera.CFrame.Position
    for _, target in pairs(Players:GetPlayers()) do
        if target ~= player and target.Character and target.Character:FindFirstChild(aimPart) then
            local part = target.Character[aimPart]
            local hum = target.Character:FindFirstChild("Humanoid")
            if hum and hum.Health > 0 and (not teamCheck or target.Team ~= player.Team) and canSeeTarget(part) then
                local dist = (part.Position - myPos).Magnitude
                if dist < shortest then shortest = dist; closest = part end
            end
        end
    end
    return closest
end

-- TELEPORT ACTION
local function attemptTeleport(btn)
    local target = acquireTargetPart()
    local myHRP = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if myHRP and target and target.Parent:FindFirstChild("HumanoidRootPart") then
        local tHRP = target.Parent.HumanoidRootPart
        if (tHRP.Position - myHRP.Position).Magnitude <= TELEPORT_THRESHOLD then
            myHRP.CFrame = tHRP.CFrame * CFrame.new(0, 0, 3)
            btn.Text = "SUCCESS"
        else btn.Text = "TOO FAR" end
    else btn.Text = "NO TARGET" end
    task.delay(1, function() btn.Text = "Teleport (<=30)" end)
end

teleportTopRightBtn.MouseButton1Click:Connect(function() attemptTeleport(teleportTopRightBtn) end)
teleportBehindBtn.MouseButton1Click:Connect(function() attemptTeleport(teleportBehindBtn) end)

-- ESP & UPDATE LOOP
local espFolder = Instance.new("Folder", screenGui)
local espBoxes = {}

RunService.RenderStepped:Connect(function()
    -- ESP Logic
    if espEnabled then
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local highlight = espBoxes[plr] or Instance.new("Highlight", espFolder)
                highlight.Adornee = plr.Character
                local dist = (plr.Character.HumanoidRootPart.Position - (player.Character and player.Character.PrimaryPart and player.Character.PrimaryPart.Position or Vector3.new())).Magnitude
                highlight.FillColor = (dist <= ESP_GREEN_THRESHOLD) and Color3.new(0,1,0) or Color3.new(1,0,0)
                espBoxes[plr] = highlight
            end
        end
    else
        espFolder:ClearAllChildren()
        espBoxes = {}
    end

    -- Aim Logic
    if aiming then
        local t = acquireTargetPart()
        if t then camera.CFrame = CFrame.new(camera.CFrame.Position, t.Position) end
    end
    
    -- Teleport Color Update
    local activeT = acquireTargetPart()
    local myHRP = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if myHRP and activeT and activeT.Parent:FindFirstChild("HumanoidRootPart") then
        local dist = (activeT.Position - myHRP.Position).Magnitude
        local color = (dist <= TELEPORT_THRESHOLD) and COLOR_ENABLED or COLOR_DISABLED
        teleportTopRightBtn.BackgroundColor3 = color
        teleportBehindBtn.BackgroundColor3 = color
    else
        teleportTopRightBtn.BackgroundColor3 = COLOR_NEUTRAL
        teleportBehindBtn.BackgroundColor3 = COLOR_NEUTRAL
    end
end)
