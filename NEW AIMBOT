--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")

--// Variables
local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local aiming = false
local espEnabled = true -- ESP ON by default
local teamCheck = false
local wallCheck = false
local aimPart = "Head"
local lockToCenter = false
local drawLines = false -- optional; requires Drawing API

-- Cycle target
local cycleMode = false
local cycleList = {}
local cycleIndex = 0
local aimOverridePart = nil
local CYCLE_LIMIT = 3

-- Thresholds
local ESP_GREEN_THRESHOLD = 8       -- ESP green within 8 studs
local TELEPORT_THRESHOLD  = 30      -- teleport allowed within 30 studs (below 31)

-- Smooth teleport settings
local TELEPORT_SPEED      = 25      -- studs per second (movement speed)
local TELEPORT_MIN_TIME   = 0.15    -- minimum tween time (s)
local TELEPORT_MAX_TIME   = 1.25    -- maximum tween time (s)
local TELEPORT_UP_OFFSET  = 0.5     -- slight vertical lift to avoid ground clipping
local TELEPORT_BACK_OFFSET= 3.0     -- offset behind target
local TELEPORT_EASE_STYLE = Enum.EasingStyle.Sine
local TELEPORT_EASE_DIR   = Enum.EasingDirection.Out

-- UI Colors
local COLOR_ENABLED = Color3.fromRGB(0, 200, 0)
local COLOR_DISABLED = Color3.fromRGB(200, 60, 60)
local COLOR_NEUTRAL = Color3.fromRGB(60, 60, 60)

--// UI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AimbotUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Enabled = true
screenGui.Parent = player:WaitForChild("PlayerGui")

local gearButton = Instance.new("ImageButton")
gearButton.Size = UDim2.new(0, 40, 0, 40)
gearButton.Position = UDim2.new(0.5, -20, 0.05, 0)
gearButton.BackgroundTransparency = 1
gearButton.Image = "rbxassetid://6031091006"
gearButton.Parent = screenGui

local menuFrame = Instance.new("Frame")
menuFrame.Size = UDim2.new(0, 260, 0, 520) -- slightly wider/taller to fit bigger buttons
menuFrame.Position = UDim2.new(0.5, -130, 0.5, -260)
menuFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
menuFrame.BorderSizePixel = 0
menuFrame.Visible = false
menuFrame.ClipsDescendants = true
menuFrame.Parent = screenGui

local uiList = Instance.new("UIListLayout")
uiList.Parent = menuFrame
uiList.Padding = UDim.new(0, 8)
uiList.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiList.VerticalAlignment = Enum.VerticalAlignment.Top

local function createToggleButton(text)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 240, 0, 36)
    button.BackgroundColor3 = COLOR_NEUTRAL
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Font = Enum.Font.SourceSans
    button.TextSize = 18
    button.Text = text .. ": OFF"
    button.AutoButtonColor = true
    return button
end

local function createButton(text)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 240, 0, 36)
    button.BackgroundColor3 = COLOR_NEUTRAL
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Font = Enum.Font.SourceSans
    button.TextSize = 18
    button.Text = text
    button.AutoButtonColor = true
    return button
end

-- Buttons in menu
local aimToggle = createToggleButton("Auto Aim")
local espToggle = createToggleButton("ESP")
local teamCheckToggle = createToggleButton("Team Check")
local wallCheckToggle = createToggleButton("Wall Check")
local aimPartToggle = createToggleButton("Aim Part: Head")
local lockCenterToggle = createToggleButton("Lock To Screen Center")
local drawLinesToggle = createToggleButton("Draw Lines")
local cycleToggle = createToggleButton("Cycle Target")
local nextTargetBtn = createButton("Next Target")
local teleportBehindBtn = createButton("Teleport Behind (<=30)") -- bigger size via createButton

aimToggle.Parent = menuFrame
espToggle.Parent = menuFrame
teamCheckToggle.Parent = menuFrame
wallCheckToggle.Parent = menuFrame
aimPartToggle.Parent = menuFrame
lockCenterToggle.Parent = menuFrame
drawLinesToggle.Parent = menuFrame
cycleToggle.Parent = menuFrame
nextTargetBtn.Parent = menuFrame
teleportBehindBtn.Parent = menuFrame

-- SECOND TELEPORT BUTTON (fixed at top-right, non-draggable) - bigger
local teleportTopRightBtn = Instance.new("TextButton")
teleportTopRightBtn.Name = "TeleportTopRight"
teleportTopRightBtn.Size = UDim2.new(0, 200, 0, 44) -- was 160x32; now larger
teleportTopRightBtn.AnchorPoint = Vector2.new(1, 0)
teleportTopRightBtn.Position = UDim2.new(1, -12, 0, 12) -- small margin tweak
teleportTopRightBtn.BackgroundColor3 = COLOR_NEUTRAL
teleportTopRightBtn.TextColor3 = Color3.new(1, 1, 1)
teleportTopRightBtn.Font = Enum.Font.SourceSansBold
teleportTopRightBtn.TextSize = 20
teleportTopRightBtn.Text = "Teleport (<=30)"
teleportTopRightBtn.AutoButtonColor = true
teleportTopRightBtn.ZIndex = 10
teleportTopRightBtn.Parent = screenGui
teleportTopRightBtn.Active = true
teleportTopRightBtn.Selectable = false

-- Dragging helper (only for gear & menu)
local function makeDraggable(guiElement)
    local dragging = false
    local dragInput, dragStart, startPos
    guiElement.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = guiElement.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    guiElement.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            guiElement.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

makeDraggable(gearButton)
makeDraggable(menuFrame)

gearButton.MouseButton1Click:Connect(function()
    menuFrame.Visible = not menuFrame.Visible
end)

-- Toggle logic
local function setToggleText(btn, label, state)
    btn.Text = label .. ": " .. (state and "ON" or "OFF")
end

aimToggle.MouseButton1Click:Connect(function()
    aiming = not aiming
    setToggleText(aimToggle, "Auto Aim", aiming)
end)

espToggle.MouseButton1Click:Connect(function()
    espEnabled = not espEnabled
    setToggleText(espToggle, "ESP", espEnabled)
end)

teamCheckToggle.MouseButton1Click:Connect(function()
    teamCheck = not teamCheck
    setToggleText(teamCheckToggle, "Team Check", teamCheck)
end)

wallCheckToggle.MouseButton1Click:Connect(function()
    wallCheck = not wallCheck
    setToggleText(wallCheckToggle, "Wall Check", wallCheck)
end)

aimPartToggle.MouseButton1Click:Connect(function()
    aimPart = (aimPart == "Head") and "HumanoidRootPart" or "Head"
    aimPartToggle.Text = "Aim Part: " .. aimPart
end)

lockCenterToggle.MouseButton1Click:Connect(function()
    lockToCenter = not lockToCenter
    setToggleText(lockCenterToggle, "Lock To Screen Center", lockToCenter)
end)

drawLinesToggle.MouseButton1Click:Connect(function()
    drawLines = not drawLines
    setToggleText(drawLinesToggle, "Draw Lines", drawLines)
end)

-- Build nearest cycle list
local function buildNearestCycleList()
    cycleList = {}
    for _, target in pairs(Players:GetPlayers()) do
        if target ~= player and target.Character and target.Character:FindFirstChild(aimPart) then
            local part = target.Character[aimPart]
            local hum = target.Character:FindFirstChild("Humanoid")
            if hum and hum.Health > 0 then
                if teamCheck and player.Team and target.Team and player.Team == target.Team then
                    -- skip teammate
                else
                    local passesWall = true
                    if wallCheck and camera and part then
                        local origin = camera.CFrame.Position
                        local direction = (part.Position - origin)
                        local rayParams = RaycastParams.new()
                        rayParams.FilterDescendantsInstances = {player.Character}
                        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                        local raycastResult = Workspace:Raycast(origin, direction.Unit * direction.Magnitude, rayParams)
                        if raycastResult and raycastResult.Instance and not part:IsDescendantOf(raycastResult.Instance.Parent) then
                            passesWall = false
                        end
                    end
                    if passesWall then
                        table.insert(cycleList, {player = target, dist = (part.Position - camera.CFrame.Position).Magnitude})
                    end
                end
            end
        end
    end
    table.sort(cycleList, function(a,b) return a.dist < b.dist end)
    if #cycleList > CYCLE_LIMIT then
        for i = CYCLE_LIMIT + 1, #cycleList do cycleList[i] = nil end
    end
end

cycleToggle.MouseButton1Click:Connect(function()
    cycleMode = not cycleMode
    setToggleText(cycleToggle, "Cycle Target", cycleMode)
    if cycleMode then
        buildNearestCycleList()
        if #cycleList == 0 then
            cycleIndex = 0; aimOverridePart = nil; nextTargetBtn.Text = "Next Target (none)"
        else
            cycleIndex = 1
            local chosen = cycleList[cycleIndex].player
            if chosen and chosen.Character and chosen.Character:FindFirstChild(aimPart) then
                aimOverridePart = chosen.Character[aimPart]
                nextTargetBtn.Text = "Next Target: " .. chosen.Name
            else
                aimOverridePart = nil; nextTargetBtn.Text = "Next Target (invalid)"
            end
        end
    else
        aimOverridePart = nil
    end
end)

nextTargetBtn.MouseButton1Click:Connect(function()
    buildNearestCycleList()
    if #cycleList == 0 then
        cycleIndex = 0; aimOverridePart = nil; nextTargetBtn.Text = "Next Target (none)"; return
    end
    cycleIndex = cycleIndex + 1
    if cycleIndex > #cycleList or cycleIndex == 0 then cycleIndex = 1 end
    local chosen = cycleList[cycleIndex].player
    if chosen and chosen.Character and chosen.Character:FindFirstChild(aimPart) then
        aimOverridePart = chosen.Character[aimPart]
        nextTargetBtn.Text = "Next Target: " .. chosen.Name
    else
        aimOverridePart = nil; nextTargetBtn.Text = "Next Target (invalid)"
    end
end)

-- Helpers
local function canSeeTarget(part)
    if not wallCheck then return true end
    local origin = camera.CFrame.Position
    local direction = (part.Position - origin)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {player.Character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = Workspace:Raycast(origin, direction.Unit * direction.Magnitude, rayParams)
    if result and result.Instance and not part:IsDescendantOf(result.Instance.Parent) then return false end
    return true
end

local function isTeammate(target)
    if not teamCheck then return false end
    if player.Team and target.Team and player.Team == target.Team then return true end
    return false
end

local function getTarget()
    local myChar = player.Character; if not myChar then return nil end
    local myHum = myChar:FindFirstChild("Humanoid"); if not myHum or myHum.Health <= 0 then return nil end
    local closest, shortestDist = nil, math.huge
    local center2d = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
    for _, target in pairs(Players:GetPlayers()) do
        if target ~= player and target.Character and target.Character:FindFirstChild(aimPart) then
            local part = target.Character[aimPart]
            local hum = target.Character:FindFirstChild("Humanoid")
            if hum and hum.Health > 0 then
                if isTeammate(target) then continue end
                if not canSeeTarget(part) then continue end
                local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
                if not onScreen then continue end
                local distFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - center2d).Magnitude
                if distFromCenter < shortestDist then shortestDist = distFromCenter; closest = part end
            end
        end
    end
    return closest
end

local function aimAt(targetPart)
    if targetPart and pcall(function() return targetPart.Position end) then
        camera.CFrame = CFrame.new(camera.CFrame.Position, targetPart.Position)
    end
end

local function acquireTargetPart()
    if cycleMode and aimOverridePart and aimOverridePart.Parent and aimOverridePart.Parent:FindFirstChild("Humanoid") then return aimOverridePart end
    if lockToCenter then return getTarget() end
    local myPos = camera.CFrame.Position
    local closest, shortest = nil, math.huge
    for _, target in pairs(Players:GetPlayers()) do
        if target ~= player and target.Character and target.Character:FindFirstChild(aimPart) then
            local part = target.Character[aimPart]
            local humT = target.Character:FindFirstChild("Humanoid")
            if humT and humT.Health > 0 and not isTeammate(target) and canSeeTarget(part) then
                local dist = (part.Position - myPos).Magnitude
                if dist < shortest then shortest = dist; closest = part end
            end
        end
    end
    return closest
end

-- =========================
-- ESP (Highlight full figure; green within 8, red otherwise)
-- =========================
local espFolder = Instance.new("Folder")
espFolder.Name = "ESPFolder"
espFolder.Parent = screenGui

local espBoxes = {}

local function createESP(playerTarget)
    if not playerTarget.Character then return nil end
    local char = playerTarget.Character
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_Highlight_" .. playerTarget.Name
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Adornee = char
    highlight.Parent = espFolder
    return { highlight = highlight }
end

local function updateESP()
    local myChar = player.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")

    -- ensure records
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player then
            if not espBoxes[plr] and espEnabled then
                local rec = createESP(plr)
                if rec then espBoxes[plr] = rec end
            end
        end
    end

    -- update or cleanup
    for plr, rec in pairs(espBoxes) do
        local char = plr and plr.Character
        local hum = char and char:FindFirstChild("Humanoid")
        local alive = hum and hum.Health > 0
        local hrp = alive and char:FindFirstChild("HumanoidRootPart") or nil
        if not espEnabled or not alive or not hrp then
            if rec.highlight then rec.highlight:Destroy() end
            espBoxes[plr] = nil
        else
            if rec.highlight.Adornee ~= char then rec.highlight.Adornee = char end
            local color = Color3.new(1, 0, 0) -- red default
            if myHRP then
                local dist = (hrp.Position - myHRP.Position).Magnitude
                if dist <= ESP_GREEN_THRESHOLD then color = Color3.new(0, 1, 0) end
            end
            rec.highlight.OutlineColor = color
            rec.highlight.FillColor = color
        end
    end
end

-- Smooth Teleport (move behind the target instead of instant)
local teleportBusy = false
local function attemptTeleportBehind(buttonToUpdate)
    if teleportBusy then return end

    local myChar = player.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then
        if buttonToUpdate then buttonToUpdate.Text = "Teleport (no HRP)" end
        task.delay(1.2, function() if buttonToUpdate then buttonToUpdate.Text = "Teleport (<=30)" end end)
        return
    end

    local targetPart = acquireTargetPart()
    if not targetPart or not targetPart.Parent then
        if buttonToUpdate then buttonToUpdate.Text = "Teleport (no target)" end
        task.delay(1.2, function() if buttonToUpdate then buttonToUpdate.Text = "Teleport (<=30)" end end)
        return
    end

    local targetHRP = targetPart.Parent:FindFirstChild("HumanoidRootPart")
    if not targetHRP then
        if buttonToUpdate then buttonToUpdate.Text = "Teleport (no HRP)" end
        task.delay(1.2, function() if buttonToUpdate then buttonToUpdate.Text = "Teleport (<=30)" end end)
        return
    end

    local dist = (targetHRP.Position - myHRP.Position).Magnitude
    if dist > TELEPORT_THRESHOLD then
        if buttonToUpdate then buttonToUpdate.Text = "Too far (>30)" end
        task.delay(1.0, function() if buttonToUpdate then buttonToUpdate.Text = "Teleport (<=30)" end end)
        return
    end

    -- Compute destination behind the target
    local backPos = targetHRP.Position - targetHRP.CFrame.LookVector * TELEPORT_BACK_OFFSET + Vector3.new(0, TELEPORT_UP_OFFSET, 0)
    local goalCFrame = CFrame.new(backPos, targetHRP.Position)

    -- Duration based on remaining distance
    local travelDist = (backPos - myHRP.Position).Magnitude
    local duration = math.clamp(travelDist / TELEPORT_SPEED, TELEPORT_MIN_TIME, TELEPORT_MAX_TIME)

    -- Play tween
    teleportBusy = true
    if buttonToUpdate then buttonToUpdate.Text = string.format("Moving (%.1fs)", duration) end

    local tween = TweenService:Create(
        myHRP,
        TweenInfo.new(duration, TELEPORT_EASE_STYLE, TELEPORT_EASE_DIR),
        { CFrame = goalCFrame }
    )

    tween:Play()

    tween.Completed:Connect(function()
        teleportBusy = false
        if buttonToUpdate then buttonToUpdate.Text = "Teleported!" end
        task.delay(1.0, function() if buttonToUpdate then buttonToUpdate.Text = "Teleport (<=30)" end end)
    end)
end

teleportBehindBtn.MouseButton1Click:Connect(function()
    attemptTeleportBehind(teleportBehindBtn)
end)

teleportTopRightBtn.MouseButton1Click:Connect(function()
    attemptTeleportBehind(teleportTopRightBtn)
end)

-- Optional line drawer
local lineDrawer
pcall(function()
    lineDrawer = Drawing.new("Line")
    lineDrawer.Color = Color3.new(1, 0, 0)
    lineDrawer.Thickness = 2
    lineDrawer.Transparency = 1
    lineDrawer.Visible = false
end)

-- Main loop
RunService.RenderStepped:Connect(function()
    -- ESP
    if espEnabled then
        updateESP()
    else
        for _, rec in pairs(espBoxes) do if rec.highlight then rec.highlight:Destroy() end end
        espBoxes = {}
    end

    -- Aim
    local targetPart = nil
    if aiming then
        if cycleMode and aimOverridePart then
            if aimOverridePart.Parent and aimOverridePart.Parent:FindFirstChild("Humanoid") then
                targetPart = aimOverridePart
                aimAt(targetPart)
            else
                aimOverridePart = nil
                buildNearestCycleList()
                if #cycleList > 0 then
                    cycleIndex = 1
                    local chosen = cycleList[cycleIndex].player
                    if chosen and chosen.Character and chosen.Character:FindFirstChild(aimPart) then
                        aimOverridePart = chosen.Character[aimPart]
                    end
                end
            end
        elseif lockToCenter then
            targetPart = getTarget()
            if targetPart then aimAt(targetPart) end
        else
            local myPos = camera.CFrame.Position
            local closest, shortest = nil, math.huge
            for _, target in pairs(Players:GetPlayers()) do
                if target ~= player and target.Character and target.Character:FindFirstChild(aimPart) then
                    local part = target.Character[aimPart]
                    local hum = target.Character:FindFirstChild("Humanoid")
                    if hum and hum.Health > 0 and not isTeammate(target) and canSeeTarget(part) then
                        local dist = (part.Position - myPos).Magnitude
                        if dist < shortest then shortest = dist; closest = part end
                    end
                end
            end
            if closest then aimAt(closest) end
        end
    end

    -- Live range UI updates for teleport buttons
    local myChar = player.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local activeTarget = acquireTargetPart()
    if myHRP and activeTarget and activeTarget.Parent then
        local targetHRP = activeTarget.Parent:FindFirstChild("HumanoidRootPart")
        if targetHRP then
            local dist = (targetHRP.Position - myHRP.Position).Magnitude
            -- Menu button
            teleportBehindBtn.Text = string.format("Teleport Behind (%.1f/<=30)", dist)
            teleportBehindBtn.BackgroundColor3 = (dist <= TELEPORT_THRESHOLD) and COLOR_ENABLED or COLOR_DISABLED
            -- Top-right button
            teleportTopRightBtn.Text = string.format("Teleport (%.1f/<=30)", dist)
            teleportTopRightBtn.BackgroundColor3 = (dist <= TELEPORT_THRESHOLD) and COLOR_ENABLED or COLOR_DISABLED
        else
            teleportBehindBtn.Text = "Teleport Behind (<=30)"
            teleportBehindBtn.BackgroundColor3 = COLOR_NEUTRAL
            teleportTopRightBtn.Text = "Teleport (<=30)"
            teleportTopRightBtn.BackgroundColor3 = COLOR_NEUTRAL
        end
    else
        teleportBehindBtn.Text = "Teleport Behind (<=30)"
        teleportBehindBtn.BackgroundColor3 = COLOR_NEUTRAL
        teleportTopRightBtn.Text = "Teleport (<=30)"
        teleportTopRightBtn.BackgroundColor3 = COLOR_NEUTRAL
    end

    -- Lines
    if lineDrawer and drawLines and aiming and targetPart then
        local screenPos, onScreen = camera:WorldToViewportPoint(targetPart.Position)
        if onScreen then
            lineDrawer.From = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y)
            lineDrawer.To = Vector2.new(screenPos.X, screenPos.Y)
            lineDrawer.Visible = true
        else
            lineDrawer.Visible = false
        end
    elseif lineDrawer then
        lineDrawer.Visible = false
    end
end)
